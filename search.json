[{"title":"JavaScript变量理解","url":"/2021/04/24/JavaScript%E5%8F%98%E9%87%8F%E7%90%86%E8%A7%A3/","content":"<p>基础不牢，地动山摇 , js变量的理解</p>\n<span id=\"more\"></span>\n\n<h1 id=\"JavaScript变量理解\"><a href=\"#JavaScript变量理解\" class=\"headerlink\" title=\"JavaScript变量理解\"></a>JavaScript变量理解</h1><p><strong>var&amp;&amp;let&amp;&amp;const</strong></p>\n<p>ECMAScript变量是<strong>松散类型</strong>的，也就意味这，变量可以保存任何类型的数据。每个变量只不过是一个用于<strong>保存任意值的命名占位符</strong></p>\n<hr>\n<h3 id=\"var\"><a href=\"#var\" class=\"headerlink\" title=\"var\"></a>var</h3><ul>\n<li><p>声明作用域为函数</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hh()&#123;</span><br><span class=\"line\">\tvar a = &#x27;hh&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hh();</span><br><span class=\"line\">console.log(a);   // 错误</span><br></pre></td></tr></table></figure></li>\n<li><p>var 声明提升</p>\n<p>  所谓提升，就是将声明拉到函数作用域的顶部 （只拉声明 ，不拉赋值）</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function com()&#123;</span><br><span class=\"line\">\tconsole.log(a);</span><br><span class=\"line\">\tvar a = &#x27;hh&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">com()   // undefined 并未出现报错</span><br><span class=\"line\"></span><br><span class=\"line\">// 上述代码等于</span><br><span class=\"line\"></span><br><span class=\"line\">function com()&#123;</span><br><span class=\"line\">\tvar a;</span><br><span class=\"line\">\tconsole.log(a);</span><br><span class=\"line\">\ta = &#x27;hh&#x27;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><ul>\n<li><p>块作用域  块 ===》 <code>&#123;&#125;</code></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if(true) &#123;</span><br><span class=\"line\">\tlet age = 26;</span><br><span class=\"line\">\tconsole.log(age);  // 26</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console,log(age);    // ReferenceError:26未定义</span><br></pre></td></tr></table></figure></li>\n<li><p>声明不会被提升</p>\n</li>\n<li><p>可全局声明 ，但不会成为window对象的属性（var）</p>\n</li>\n<li><p>不允许重复声明</p>\n</li>\n</ul>\n<h3 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h3><ul>\n<li><p>与let相似 唯一一个重要的区别是<strong>声明变量时必须要初始化，且不允许修改</strong></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const a ;  // 错误</span><br><span class=\"line\">cosnt a = 5 ; </span><br><span class=\"line\"></span><br><span class=\"line\">// const 也不允许重复声明</span><br><span class=\"line\">const name = &#x27;白小剑&#x27;</span><br><span class=\"line\">const name = &#x27;秦始皇&#x27; // SyntaxError</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"生命风格以及最佳实践\"><a href=\"#生命风格以及最佳实践\" class=\"headerlink\" title=\"生命风格以及最佳实践\"></a>生命风格以及最佳实践</h3><ul>\n<li><p>不使用 <strong>var</strong></p>\n</li>\n<li><p><strong>const</strong> 优先 <strong>let</strong> 次之</p>\n<p>  使用<strong>const</strong> 可以使浏览器强制保持变量不变 ， 只在提前知道变量会修改时使用<strong>let</strong>来声明</p>\n</li>\n</ul>\n","categories":["JavaScript"],"tags":["JavaScript变量"]},{"title":"Vue双向绑定原理","url":"/2022/01/11/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/","content":"<p>vue双向绑定的原理哇 ， 看的虽然头疼 不过还是收获蛮大滴！！</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Vue的双向绑定剖析Vue原理-amp-实现双向绑定MVVM-SegmentFault-思否\"><a href=\"#Vue的双向绑定剖析Vue原理-amp-实现双向绑定MVVM-SegmentFault-思否\" class=\"headerlink\" title=\"Vue的双向绑定剖析Vue原理&amp;实现双向绑定MVVM - SegmentFault 思否\"></a>Vue的双向绑定<a href=\"https://segmentfault.com/a/1190000006599500#item-3\">剖析Vue原理&amp;实现双向绑定MVVM - SegmentFault 思否</a></h1><ul>\n<li>Mvc 模式  到  mvvm模式 的转变 </li>\n</ul>\n<p><img src=\"https://wfx7jb3ja4.feishu.cn/space/api/box/stream/download/asynccode/?code=NjBmYjI4ZWE5MmJlNmYyN2U3NjY2ODBhOWJhZjhkNDRfckNtOXp6ZGRKT2pQdEUxY0VQMWRpUnpMNFRPMlJ3MWxfVG9rZW46Ym94Y253MG5TenpERXBPNTlXNHlqVzVocXBoXzE2NDE5MDk0MTQ6MTY0MTkxMzAxNF9WNA\" alt=\"img\"></p>\n<ul>\n<li><p>Mvc 模式 controler 层要大量的控制dom</p>\n</li>\n<li><p>Mvvm 模式 是真正做到了数据与视图的分离，  view 和 model 改变时 ， vm层自动进行数据和视图的同步</p>\n</li>\n<li><p>vue.js 采用数据劫持结合发布者-订阅者模式的方式 ， 通过Object.defineProperty()来劫持各个属性的setter、getter，在数据监听时发布消息给订阅者 ， 触发响应的监听回调</p>\n</li>\n<li><p>发布 订阅者模式让双向绑定更有效率（一对多）</p>\n</li>\n<li><p>实现一个数据监听器 Observer </p>\n<ul>\n<li>核心是 Object.defineProperty() ， 将Observe的数据对象进行递归遍历 ， 包括子属性的对象加上setter getter方法 ， 赋值时就会调用setter方法，就监听到了数据变化</li>\n<li>通知订阅者</li>\n</ul>\n</li>\n<li><p>实现Compile </p>\n<ul>\n<li>解析模板的指令 ， 将模板中的变量替换成数据 ，</li>\n<li>初始化页面渲染 ， </li>\n<li>并绑定更新函数 ， 添加监听数据的订阅者 ， 一但数据有变化 ， 更新视图</li>\n</ul>\n</li>\n<li><p>实现watcher （解析 compile 和 observe 的桥梁）</p>\n<ul>\n<li>实例化在订阅者添加自己</li>\n<li>自己有一个update()方法</li>\n<li>待属性变动 ， 接受通知，调用自身的update() , 并触发compile中的回调</li>\n</ul>\n</li>\n<li><p>整合形成一个mvvm</p>\n</li>\n</ul>\n<p><img src=\"https://wfx7jb3ja4.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFjZjMzMzJjNWMxYmYxY2QyNWUxYmZhMWEzMzkxNTdfVzJHR0Rzd0NZajNWMWVSczBYYWZ4T1gwRXdZMHV6dUJfVG9rZW46Ym94Y240cmRGa1kwYnloNDlWTnA4YzR1dVhmXzE2NDE5MDk0MTQ6MTY0MTkxMzAxNF9WNA\" alt=\"img\"></p>\n<p><img src=\"https://wfx7jb3ja4.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjFhNGFlMGVkMDUxNDliNjM4ZWU2ZTVjNTFmYmQ4N2RfRTJyVlI4VnJKdkNiODRya2hETWdadXpmcTNwRzMweldfVG9rZW46Ym94Y25DSmVLR2NYb3FrN1hlYkRKMjhsZTF2XzE2NDE5MDk0MTQ6MTY0MTkxMzAxNF9WNA\" alt=\"img\"></p>\n","categories":["Vue"],"tags":["Vue双向绑定"]},{"title":"CSS动画基础","url":"/2021/04/24/CSS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/","content":"<p>华丽的视觉体验源自于艺术家的精心雕琢</p>\n<span id=\"more\"></span>\n\n<p></style></p>\n<div class=\"demo-1\">\n        <div class=\"circle\">\n            <div class=\"word\"><p>简 单 动 画</p></div>\n        </div>\n    </div>\n<style>\n.demo-1 .circle {\n  width: 200px;\n  height: 200px;\n  background: #FFFF99;\n  margin: 0 auto;\n  border-radius: 50%;\n  position: relative;\n  animation: jump 1.5s cubic-bezier(0.41, -0.04, 0.93, 0.29)  infinite alternate;\n}\n@keyframes jump {\n  0% {\n    transform: translateX(0px);\n  }\n  40% {\n    transform: translateX(150px);\n    clip-path: ellipse(50% 50% at 50% 50%);\n  }\n  50% {\n    transform: translateX(150px);\n    clip-path: ellipse(46% 50% at 46% 50%);\n  }\n  90% {\n    transform: translateX(0px);\n    clip-path: ellipse(50% 50% at 50% 50%);\n  }\n  100% {\n    transform: translateX(0px);\n    clip-path: ellipse(80% 50% at 80% 50%);\n  }\n}\n.demo-1 .circle .word {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background: #CC9999;\n  border-radius: 30%;\n  height:30px;\n}\n.demo-1 .circle .word p {\n  color: #666699;\n}\n</style>\n<div id=\"catalog\">索引</div>\n<style>\n#catalog{\n            color: #1CA28A;\n            font-size: 30px;\n            font-weight: bold;\n            width: 60px;\n            height: 40px;\n            animation: bigger 2s ease-in 0.5s  infinite alternate;\n            font-family:\"微软雅黑\",\"黑体\",\"宋体\";\n        margin-left：50px;\n        } \n        @keyframes bigger {\n            0%{\n                transform:scale(0.7);\n            }\n            50%{\n                transform:scale(0.9);\n            }\n            100%{\n                transform:scale(1.2);\n            }\n        }\n</style>\n\n<style>\n        #side-menu {\n            list-style: none;\n            border: 3px solid #1CA28A    ;\n            border-radius: 10px;\n            width: 300px;\n            padding: 20px;\n            background: #88AE5C;\n        margin:0 auto;\n        margin-bottom: 50px;\n        }\n\n        #side-menu li {\n            font-size: 18px;\n            line-height: 2.4em;\n            border-bottom: dotted 1px grey ;\n            /* 添加分隔符 */\n        }\n        #side-menu span{\n            font-weight: bolder;\n            color: khaki;\n        } \n        #side-menu li:last-child {\n            border: none;\n            /* 取消最后一个分隔符 */\n        }\n        #side-menu li a {\n            color: #EFD735    ;\n            text-decoration: none;\n        }\n        #side-menu li a:hover {\n            color: rgb(255, 100, 200);\n        }\n</style>\n<ul id='side-menu'>\n    <li><a href=\"#download\"><span>①</span> 介绍</a></li>\n    <li><a href=\"#unzip\"><span>②</span> Transition 基础写法和经验</a></li>\n    <li><a href=\"#settings\"><span>③</span> animation 写法和经验总结</a></li>\n    <li><a href=\"#compile\"><span>④</span> 时间函数</a></li>\n</ul>\n\n\n<div style=\"width:92%;color:#EFD735;font-size:25px;display: inline-block;margin-top:20px;margin-bottom:20px;\" id=\"download\"><strong><span>①</span> 介绍</a></strong></div>\n\n\n<ul>\n<li>css3动画包括 <strong>transtion</strong> 和 <strong>animation</strong>   </li>\n<li></li>\n<li>动画常和<strong>transform属性</strong>常用</li>\n<li></li>\n<li>transform并不是动画属性</li>\n</ul>\n<div style=\"width:92%;color:#EFD735;font-size:25px;display: inline-block;margin-top:20px;margin-bottom:20px;\" id=\"unzip\"><strong><span>②</span> Transition 基础写法和经验</a></strong></div>\n\n<p><strong>过渡</strong></p>\n<p><strong>基础写法</strong>  ：  属性名称   过渡时间   时间函数   延迟时间    （顺序 书写规范）</p>\n<p><strong>用法注意</strong>： </p>\n<ul>\n<li>①属性有变化的时候才会过渡   </li>\n<li>②初始化后再应用   </li>\n<li>③时间函数改变动画速度</li>\n</ul>\n<p>tip： </p>\n<ul>\n<li>1.display 不能和transition一起使用  （文档流限制）</li>\n<li></li>\n<li>2.transition 尽量不用all</li>\n<li></li>\n<li>3.常见的闪动   我们可以  perspective  和 backface-visibility</li>\n<li></li>\n<li>4.详见时间函数 <a href=\"https://blog.csdn.net/zhy13087344578/article/details/79651857\">时间函数</a></li>\n</ul>\n<p><strong>拓展：</strong></p>\n<p><strong>transform属性</strong>：<a href=\"https://www.w3school.com.cn/cssref/pr_transform.asp\">教程</a></p>\n<p>transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行<strong>旋转、缩放、移动或倾斜</strong>。</p>\n<p>常见属性</p>\n<ul>\n<li><strong>translate</strong>  translateX translateY   x轴 y轴 定向移动    单位：百分比或者px</li>\n<li></li>\n<li><strong>scaleX（x，y）</strong>  缩放比例  填倍数</li>\n<li></li>\n<li><strong>rotate(<em>angle</em>)</strong>   旋转角度   rotate(60deg)</li>\n<li></li>\n<li><strong>skew（angle）</strong>  倾斜角度</li>\n</ul>\n<div style=\"width:92%;color:#EFD735;font-size:25px;display: inline-block;margin-top:20px;margin-bottom:20px;\" id=\"settings\"><strong><span>③</span> animation 写法和经验总结</a></strong></div>\n\n<p><strong>组建动画</strong></p>\n<p><strong>基础写法</strong>：<a href=\"https://www.w3school.com.cn/cssref/pr_animation.asp\">教程</a></p>\n<p> 动画名称（name）--@keyframe    过渡时间     时间函数   延迟时间</p>\n<p>播放次数   播放方向   停止播放   是否暂停</p>\n<p>tip：</p>\n<ul>\n<li>1.animation 解决了transtion display：none  的BUG   （手动添加）</li>\n<li></li>\n<li>2.可实现跳动  根据百分比切换</li>\n</ul>\n<div style=\"width:92%;color:#EFD735;font-size:25px;display: inline-block;margin-top:20px;margin-bottom:20px;\" id=\"compile\"><strong><span>④</span> 时间函数</a></strong></div>\n\n<ul>\n<li><a href=\"https://blog.csdn.net/zhy13087344578/article/details/79651857\">时间函数</a></li>\n<li></li>\n<li>线性 ：cubic-bezier  实现动画的线性过渡</li>\n<li></li>\n<li>非线性：steps （1，start|end）  实现动画的阶跃变化</li>\n</ul>\n<p><strong>简单应用：</strong></p>\n<p>loading：<br><img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/f22d4de2-0638-47c1-8d21-4e4beacb6e12.png\" alt=\"image.png\"></p>\n","categories":["CSS"],"tags":["动画"]},{"title":"Vue实现动态面包屑","url":"/2021/08/30/Vue%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%9D%A2%E5%8C%85%E5%B1%91/","content":"<p>vue实现动态面包屑</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Vue实现动态面包屑\"><a href=\"#Vue实现动态面包屑\" class=\"headerlink\" title=\"Vue实现动态面包屑\"></a>Vue实现动态面包屑</h1><h3 id=\"1-使用elementui-组件中的-el-breadcrumb\"><a href=\"#1-使用elementui-组件中的-el-breadcrumb\" class=\"headerlink\" title=\"1.使用elementui 组件中的 el-breadcrumb\"></a>1.使用elementui 组件中的 el-breadcrumb</h3><ul>\n<li><code>v-for</code>遍历路径的数组</li>\n<li>利用<code>router.meta</code> 添加<code>title 、 path</code> </li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> &lt;el-breadcrumb separator=&quot;/&quot;&gt;</span><br><span class=\"line\">\t\t\t  &lt;el-breadcrumb-item v-for=&quot;(item , index) in breadList&quot; :key=&quot;item.index&quot; :to=&quot;\t\t\t\t &#123;path:item.meta.path&#125;&quot; &gt;</span><br><span class=\"line\">\t\t\t  &lt;/el-breadcrumb-item&gt;</span><br><span class=\"line\">&lt;/el-breadcrumb&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-利用vue-router对象属性-route-matched\"><a href=\"#2-利用vue-router对象属性-route-matched\" class=\"headerlink\" title=\"2.利用vue-router对象属性 $route.matched\"></a>2.利用vue-router对象属性 <code>$route.matched</code></h3><ul>\n<li>类型：<code>Array&lt;RouteRecord&gt;</code></li>\n<li>一个<strong>数组</strong> 包含当前路由的所有嵌套路径的路由记录</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 建立一个数组 存放面包屑的路径</span><br><span class=\"line\">data()&#123;</span><br><span class=\"line\">  \treturn&#123;</span><br><span class=\"line\">  \t\tbreadList:[]</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">// 监听路由变化 并且把路由路径放置数组中</span><br><span class=\"line\">watch:&#123;</span><br><span class=\"line\"> $route()&#123;</span><br><span class=\"line\"> \tthis.getBreadcrumb();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">\tgetBreadcrumb()&#123;</span><br><span class=\"line\">\t\t\tlet matched = this.$route.matched;</span><br><span class=\"line\">\t\t\tthis.breadList=matched;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 初始化</span><br><span class=\"line\">created()&#123;</span><br><span class=\"line\">\tthis.getBreadcrumb()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-router-js-中进行路由的元信息配置-meta\"><a href=\"#3-router-js-中进行路由的元信息配置-meta\" class=\"headerlink\" title=\"3. router.js 中进行路由的元信息配置 meta\"></a>3. router.js 中进行路由的元信息配置 <code>meta</code></h3><ul>\n<li>子路由只需配置 <code>meta:&#123;title: &#39;title&#39;&#125;</code></li>\n<li>父路由 、 父父路由配置<code>path</code>跳转 <code>meta: &#123;title: &#39;title&#39; , path:&#39;path&#39;&#125;,</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 业务管理</span><br><span class=\"line\">      // 业务管理主页</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &#x27;/configManage/businessManage&#x27;,</span><br><span class=\"line\">      name:&#x27;businessManage&#x27;,</span><br><span class=\"line\">      component: BusinessManage,</span><br><span class=\"line\">      meta: &#123;title: &#x27;业务管理主页&#x27; , path:&#x27;/configManage/businessManage&#x27;&#125;,</span><br><span class=\"line\">      children:[</span><br><span class=\"line\">          // 业务增加</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path:&#x27;/configManage/businessAdd&#x27;,</span><br><span class=\"line\">          name:&#x27;businessAdd&#x27;,</span><br><span class=\"line\">          component:BusinessAdd,</span><br><span class=\"line\">          meta:&#123;title: &#x27;业务增加&#x27;&#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">          // 业务编辑</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path:&#x27;/configManage/businessEdit&#x27;,</span><br><span class=\"line\">          name:&#x27;businessEdit&#x27;,</span><br><span class=\"line\">          component:BusinessEdit,</span><br><span class=\"line\">          meta: &#123;title: &#x27;业务编辑&#x27;&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">          // 业务查看</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path:&#x27;/configManage/businessView&#x27;,</span><br><span class=\"line\">          name:&#x27;businessView&#x27;,</span><br><span class=\"line\">          component:BusinessView,</span><br><span class=\"line\">          meta: &#123;title: &#x27;业务查看&#x27;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br></pre></td></tr></table></figure>\n\n","categories":["Vue"],"tags":["动态面包屑"]},{"title":"ES6模板字面量","url":"/2021/04/25/ES6%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F/","content":"<p>ES6语法 模板字面量 ， 本文介绍了字面量的基本用法以及含义</p>\n<span id=\"more\"></span>\n\n<h1 id=\"ES6-模板字面量\"><a href=\"#ES6-模板字面量\" class=\"headerlink\" title=\"ES6 模板字面量\"></a>ES6 模板字面量</h1><h3 id=\"1-基本含义\"><a href=\"#1-基本含义\" class=\"headerlink\" title=\"1. 基本含义\"></a>1. 基本含义</h3><ul>\n<li><p>保留换行字符，跨行定义字符串</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let hh = &#x27;我是\\n宋泽剑&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">let hh =  `我是</span><br><span class=\"line\">宋泽剑 `</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">我是</span><br><span class=\"line\">宋泽剑</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></li>\n<li><p>保持反引号内部的空格</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let hh =  `我是</span><br><span class=\"line\">\t\t\t宋泽剑 `</span><br><span class=\"line\">console.log(hh.length)   //47</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-支持字符串插值\"><a href=\"#2-支持字符串插值\" class=\"headerlink\" title=\"2.支持字符串插值\"></a>2.支持字符串插值</h3><ul>\n<li><p>插值表达式：<code>$&#123;&#125;</code> </p>\n</li>\n<li><p>可以放变量，还可以进行运算</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let value = 5</span><br><span class=\"line\"></span><br><span class=\"line\">let exponet = &#x27;second&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">let hh = `$&#123;value&#125; to the $&#123;exponet&#125; power is $&#123;value * value&#125;`;</span><br><span class=\"line\"></span><br><span class=\"line\">// 5 to the second power is 25  </span><br></pre></td></tr></table></figure></li>\n<li><p>可以插入函数和方法</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hh(word)&#123;</span><br><span class=\"line\">\treturn`$&#123;word[0].toUpperCase&#125;$&#123;word.slice(1)&#125;`</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"3-模板自面量标签函数\"><a href=\"#3-模板自面量标签函数\" class=\"headerlink\" title=\"3. 模板自面量标签函数\"></a>3. 模板自面量标签函数</h3><ul>\n<li><p>标签函数会接受被插值记号分隔后的模板和表达式求值的结果</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function simpleTag(strings, aValExpression, bValExpression, sumExpression) &#123; </span><br><span class=\"line\"> console.log(strings); </span><br><span class=\"line\"> console.log(aValExpression); </span><br><span class=\"line\"> console.log(bValExpression); </span><br><span class=\"line\"> console.log(sumExpression); </span><br><span class=\"line\"> return &#x27;foobar&#x27;; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">let a = 6;</span><br><span class=\"line\">let b = 9;</span><br><span class=\"line\">let hh = simpleTag`$&#123;a&#125; + $&#123;b&#125; = $&#123;a+b&#125;`</span><br><span class=\"line\">// strings ==&gt; &quot;&quot;,&quot; + &quot;,&quot; + = &quot;,&quot;&quot; 分隔后的模板</span><br><span class=\"line\">// 6</span><br><span class=\"line\">// 9</span><br><span class=\"line\">// 15</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"4-原始字符串\"><a href=\"#4-原始字符串\" class=\"headerlink\" title=\"4.原始字符串\"></a>4.原始字符串</h3><ul>\n<li><p>获取原始内容</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(`\\u00A9`)   </span><br><span class=\"line\">//© </span><br></pre></td></tr></table></figure></li>\n<li><p>String.raw  字母含义</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(String.raw`\\u00A9`)</span><br><span class=\"line\">// \\u00A9</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n","categories":["ES6"],"tags":["模板字面量"]},{"title":"JavaScript事件处理器（事件监听器）","url":"/2021/08/11/JavaScript%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%89/","content":"<p><strong>事件</strong>是您在编程时，系统内部发生的事情或发生的动作</p>\n<span id=\"more\"></span>\n\n<h1 id=\"JavaScript事件处理器（事件监听器）\"><a href=\"#JavaScript事件处理器（事件监听器）\" class=\"headerlink\" title=\"JavaScript事件处理器（事件监听器）\"></a>JavaScript事件处理器（事件监听器）</h1><h3 id=\"事件简介\"><a href=\"#事件简介\" class=\"headerlink\" title=\"事件简介\"></a>事件简介</h3><ul>\n<li><strong>事件</strong>是您在编程时，系统内部发生的事情或发生的动作</li>\n<li>系统会在事件发生时产生某种信号，并且提供一个自动加载某种动作的机制<ul>\n<li> 闹钟响了 ==》 事件 </li>\n<li> 我睁开眼睛意识清醒  ==》响应机制</li>\n</ul>\n</li>\n<li>在web中 用户点击鼠标 敲击键盘 都是事件 ， 每一个可用的事件都有一个<strong>事件处理器</strong>，也称为<strong>事件监听器</strong>。 用来执行事件的响应机制。</li>\n</ul>\n<h3 id=\"常用的事件监听器\"><a href=\"#常用的事件监听器\" class=\"headerlink\" title=\"常用的事件监听器\"></a>常用的事件监听器</h3><h4 id=\"1-事件处理器属性\"><a href=\"#1-事件处理器属性\" class=\"headerlink\" title=\"1. 事件处理器属性\"></a>1. 事件处理器属性</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const btn = document.querySelector(&#x27;button&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">btn.onclick = function() &#123;</span><br><span class=\"line\">  const rndCol = &#x27;rgb(&#x27; + random(255) + &#x27;,&#x27; + random(255) + &#x27;,&#x27; + random(255) + &#x27;)&#x27;;</span><br><span class=\"line\">  document.body.style.backgroundColor = rndCol;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>onclick</code>是被用在这个情境下的事件处理器的属性，就像button 其他的属性</p>\n<h4 id=\"2-行内事件处理器-（请勿使用）\"><a href=\"#2-行内事件处理器-（请勿使用）\" class=\"headerlink\" title=\"2. 行内事件处理器 （请勿使用）\"></a>2. 行内事件处理器 （请勿使用）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button onclick=&quot;bgChange()&quot;&gt;Press me&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function bgChange() &#123;</span><br><span class=\"line\">  const rndCol = &#x27;rgb(&#x27; + random(255) + &#x27;,&#x27; + random(255) + &#x27;,&#x27; + random(255) + &#x27;)&#x27;;</span><br><span class=\"line\">  document.body.style.backgroundColor = rndCol;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Web上注册事件处理程序的最早方法是类似于上面所示的<strong>事件处理程序HTML属性</strong>(也称为内联事件处理程序)—属性值实际上是当事件发生时要运行的JavaScript代码。上面的例子中调用一个在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script\">``</a>元素在同一个页面上，但也可以直接在属性内插入JavaScript，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button onclick=&quot;alert(&#x27;Hello, this is my old-fashioned event handler!&#x27;);&quot;&gt;Press me&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p>使用一个事件处理的属性似乎看起来非常的简单，如果你追求性能与用户体验，这很快就变得难以管理和效率低下</p>\n<p>原因：</p>\n<ul>\n<li><p>混用<code>HTML</code> <code>JavaScript</code>文档很难解析  ==》最好的方法是只在一块地方写J<code>avaScript</code>代码</p>\n</li>\n<li><p>对批量的事件处理不友好 ，如果仅仅是一个按钮，无伤大雅，但100个 1000个按钮呢？ 使用JavaScript 可以给网页中的button都加上事件处理器</p>\n<ul>\n<li>```<br>  const buttons = document.querySelectorAll(‘button’);  for (let i = 0; i &lt; buttons.length; i++) {<pre><code>buttons[i].onclick = bgChange;\n</code></pre>\n  }  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 将编程逻辑与内容分离也会让你的站点对搜索引擎更加友好</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### 3. `addEventListener() 和removeEventListener()`</span><br><span class=\"line\"></span><br><span class=\"line\">新的事件触发机制被定义在[Document Object Model (DOM) Level 2 Events Specification (w3.org)](https://www.w3.org/TR/DOM-Level-2-Events/)，这个事件处理属性是类似的，但是语法略有不同，我们可以重写以上的代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nconst btn = document.querySelector(‘button’);</li>\n</ul>\n</li>\n</ul>\n<p>function bgChange() {<br>  const rndCol = ‘rgb(‘ + random(255) + ‘,’ + random(255) + ‘,’ + random(255) + ‘)’;<br>  document.body.style.backgroundColor = rndCol;<br>}</p>\n<p>btn.addEventListener(‘click’, bgChange);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 在 `addEventListener()`中具体化了两个参数（事件类型 ， 匿名函数）</span><br><span class=\"line\"></span><br><span class=\"line\">    - ```</span><br><span class=\"line\">        btn.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class=\"line\">          var rndCol = &#x27;rgb(&#x27; + random(255) + &#x27;,&#x27; + random(255) + &#x27;,&#x27; + random(255) + &#x27;)&#x27;;</span><br><span class=\"line\">          document.body.style.backgroundColor = rndCol;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>同时相对于旧方式，此方式提供了一个优点，就是可以移除监听器<code>removeEventListener()</code></p>\n<ul>\n<li>```<br>  btn.removeEventListener(‘click’ , bgChange);  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 大型 复杂的项目中非常有用！</span><br><span class=\"line\"></span><br><span class=\"line\">    - 高效的清楚不用的事件处理器</span><br><span class=\"line\"></span><br><span class=\"line\">    - 给一个监听器注册多个响应函数</span><br><span class=\"line\"></span><br><span class=\"line\">        - ```</span><br><span class=\"line\">            myele.addEventListener(&#x27;click&#x27; , A());</span><br><span class=\"line\">            myele.addEventListener(&#x27;click&#x27; , B());</span><br><span class=\"line\">            // 一次触发 可以响应两个或多个事件</span><br><span class=\"line\">            myele.click = A();</span><br><span class=\"line\">            myele.click = B();</span><br><span class=\"line\">            // 属性会覆盖</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"我该用哪个？\"><a href=\"#我该用哪个？\" class=\"headerlink\" title=\"我该用哪个？\"></a>我该用哪个？</h3><ul>\n<li>前两种方式，相对于比较简单的用途，是可以相对互换的</li>\n<li>首先<strong>不推荐使用行内事件处理器</strong></li>\n<li>如果项目比较小，并且需要有较高的跨浏览器兼容性，<strong>推荐使用事件处理程序属性</strong></li>\n<li><strong>推荐<code>addEventListener() 和removeEventListener()</code></strong> 对于同一类元素可以添加多个事件监听器，并且监听器在不用时可以移除</li>\n</ul>\n<h3 id=\"addEventListener实战场景举例\"><a href=\"#addEventListener实战场景举例\" class=\"headerlink\" title=\"addEventListener实战场景举例\"></a><code>addEventListener</code>实战场景举例</h3><h4 id=\"1-监听鼠标滚轮实现表格横向滚动\"><a href=\"#1-监听鼠标滚轮实现表格横向滚动\" class=\"headerlink\" title=\"1. 监听鼠标滚轮实现表格横向滚动\"></a>1. 监听鼠标滚轮实现表格横向滚动</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 鼠标绑定事件</span><br><span class=\"line\">scrollFunction () &#123;</span><br><span class=\"line\">\t\t\tthis.scrollDom = document.getElementById(&quot;center__left&quot;) // 通过id获取要设置的div</span><br><span class=\"line\">\t\t\tthis.scrollDom.addEventListener(&quot;wheel&quot;, this.mouseScroll, false);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">// 监听响应函数</span><br><span class=\"line\">mouseScroll(event) &#123; </span><br><span class=\"line\">\t\t\tlet detail = event.wheelDelta || event.detail // 适配浏览器</span><br><span class=\"line\">\t\t\tlet moveForwardStep = -1  // 前滚</span><br><span class=\"line\">\t\t\tlet moveBackStep = 1 // 后滚</span><br><span class=\"line\">\t\t\tlet step = 0</span><br><span class=\"line\">\t\t\tstep = detail &gt; 0 ? moveForwardStep * 100 : moveBackStep * 100</span><br><span class=\"line\">\t\t\tthis.scrollDom.scrollLeft = this.scrollDom.scrollLeft + step</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">// 卸载监听器</span><br><span class=\"line\">\tbeforeDestroy()&#123;</span><br><span class=\"line\">\t\t// 卸载监听器</span><br><span class=\"line\">\t\tif (!this.scrollDom) return</span><br><span class=\"line\">\t\tif (this.scrollDom.addEventListener) &#123;</span><br><span class=\"line\">\t\t\tthis.scrollDom.removeEventListener(&quot;wheel&quot;, this.mouseScroll, false)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-监听浏览器刷新事件实现sessionStorage值不丢失\"><a href=\"#2-监听浏览器刷新事件实现sessionStorage值不丢失\" class=\"headerlink\" title=\"2. 监听浏览器刷新事件实现sessionStorage值不丢失\"></a>2. 监听浏览器刷新事件实现sessionStorage值不丢失</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">created() &#123;</span><br><span class=\"line\">\t\t// 监听刷新事件</span><br><span class=\"line\">\t\twindow.addEventListener(&quot;unload&quot;,()=&gt;&#123;</span><br><span class=\"line\">\t\t\t// 将state中的值存入session 并标记位list</span><br><span class=\"line\">\t\t\tsessionStorage.setItem(&quot;list&quot; , JSON.stringify(this.$store.state.userData));</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\t// 将list中的值取出 并且处理为对象格式</span><br><span class=\"line\">\t\tlet data=JSON.parse(sessionStorage.getItem(&quot;list&quot;));</span><br><span class=\"line\">\t\t// 将vuex中的值存入vuex中</span><br><span class=\"line\">\t\tthis.$store.commit(&quot;resetState&quot; , data);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">// 清除前卸载</span><br><span class=\"line\">beforeDestroy() &#123;</span><br><span class=\"line\">\t\twindow.removeEventListener(&quot;unload&quot;, () =&gt; &#123;</span><br><span class=\"line\">\t\t\t// 将state中的值存入session 并标记位list</span><br><span class=\"line\">\t\t\tsessionStorage.setItem(&quot;list&quot;, JSON.stringify(this.$store.state.userData));</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["JavaScript"],"tags":["JavaScript事件处理器"]},{"title":"Vue路由守卫","url":"/2021/08/20/Vue%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/","content":"<p>路由守卫是什么 ， 以及如何使用？</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Vue路由守卫\"><a href=\"#Vue路由守卫\" class=\"headerlink\" title=\"Vue路由守卫\"></a>Vue路由守卫</h1><h3 id=\"1-全局前置守卫\"><a href=\"#1-全局前置守卫\" class=\"headerlink\" title=\"1. 全局前置守卫\"></a>1. 全局<strong>前置</strong>守卫</h3><ul>\n<li>三个参数<ul>\n<li><code>to</code> 即将进入的目标路由对象</li>\n<li><code>from</code> 当前导航即将离开的路由对象</li>\n<li><code>next：functiotn</code>  <ul>\n<li><code>next()</code> 进行管道中的下一个钩子  </li>\n<li><code>next(false)</code> 中断当前导航 </li>\n<li><code>nuxt(&#39;/&#39;)</code> 进入根路径</li>\n<li><strong><code>next(error)</code></strong>: 终止且该错误会被传递给 <code>router.onError()</code> 注册过的回调。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次</strong></li>\n<li><strong>但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错</strong>。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">router.beforeEach((to , from , next ) =&gt; &#123;</span><br><span class=\"line\">  //进入登录页 没有限制</span><br><span class=\"line\">  if(to.path === &#x27;/login&#x27;)&#123;</span><br><span class=\"line\">    next();</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 当需要登录检验的页面时</span><br><span class=\"line\">  if(!to.meta.auth)&#123;</span><br><span class=\"line\">    // 请求登录状态</span><br><span class=\"line\">    Http.loginState().then(res =&gt;&#123;</span><br><span class=\"line\">      if (res.code === &#x27;SUCCESS&#x27;)&#123;</span><br><span class=\"line\">        // 如果为登陆状态执行预进入的路由</span><br><span class=\"line\">        next()</span><br><span class=\"line\">      &#125;else &#123;</span><br><span class=\"line\">        // 否则 弹窗提示进入登录页</span><br><span class=\"line\">        MessageBox.alert(&#x27;您还未登录哦！&#x27;, &#123;</span><br><span class=\"line\">          showClose: false,</span><br><span class=\"line\">          type: &#x27;warning&#x27;,</span><br><span class=\"line\">          center: true,</span><br><span class=\"line\">          callback: () =&gt; &#123;</span><br><span class=\"line\">            router.push(&#123;</span><br><span class=\"line\">              path: &#x27;/&#x27;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;else &#123;</span><br><span class=\"line\">    next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-全局后置钩子\"><a href=\"#2-全局后置钩子\" class=\"headerlink\" title=\"2. 全局后置钩子\"></a>2. 全局后置钩子</h3><ul>\n<li>不会接受next钩子</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">router.afterEach((to, from) =&gt; &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-路由独享的守卫\"><a href=\"#3-路由独享的守卫\" class=\"headerlink\" title=\"3. 路由独享的守卫\"></a>3. 路由独享的守卫</h3><ul>\n<li>路由配置上直接定义</li>\n<li>一定要记住有<code>next()</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &#x27;/&#x27;,</span><br><span class=\"line\">      component: Login,</span><br><span class=\"line\">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class=\"line\">\t\t\tnext();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-组件内的守卫\"><a href=\"#4-组件内的守卫\" class=\"headerlink\" title=\"4. 组件内的守卫\"></a>4. 组件内的守卫</h3><ul>\n<li><p><code>beforeRouteEnter</code></p>\n<ul>\n<li><p>不可以访问<code>this</code> </p>\n</li>\n<li><p>你可以通过传一个回调<code>vm</code>给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>\n</li>\n<li><p>```<br>  beforeRouteEnter (to, from, next) {</p>\n<pre><code>next(vm =&gt; &#123;\n  // 通过 `vm` 访问组件实例\n&#125;)\n</code></pre>\n<p>  }</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- `beforeRouteUpdate`</span><br><span class=\"line\"></span><br><span class=\"line\">- `beforeRouteLeave`</span><br><span class=\"line\"></span><br><span class=\"line\">    - 常见用法： 退出界面是是否保存修改</span><br><span class=\"line\"></span><br><span class=\"line\">    - ```js</span><br><span class=\"line\">        beforeRouteLeave (to, from, next) &#123;</span><br><span class=\"line\">          const answer = window.confirm(&#x27;Do you really want to leave? you have unsaved changes!&#x27;)</span><br><span class=\"line\">          if (answer) &#123;</span><br><span class=\"line\">            next()</span><br><span class=\"line\">          &#125; else &#123;</span><br><span class=\"line\">            next(false)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><pre><code>  const Foo = &#123;\n    template: `...`,\n    beforeRouteEnter(to, from, next) &#123;\n      // 在渲染该组件的对应路由被 confirm 前调用\n      // 不！能！获取组件实例 `this`\n      // 因为当守卫执行前，组件实例还没被创建\n    &#125;,\n    beforeRouteUpdate(to, from, next) &#123;\n      // 在当前路由改变，但是该组件被复用时调用\n      // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n      // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n      // 可以访问组件实例 `this`\n    &#125;,\n    beforeRouteLeave(to, from, next) &#123;\n      // 导航离开该组件的对应路由时调用\n      // 可以访问组件实例 `this`\n    &#125;\n  &#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["Vue"],"tags":["Vue路由守卫"]},{"title":"flex布局在react-native中的运用","url":"/2021/04/29/flex%E5%B8%83%E5%B1%80%E5%9C%A8react-native%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/","content":"<p>flex布局在react-native 移动端的应用</p>\n<span id=\"more\"></span>\n\n<h1 id=\"flex-布局\"><a href=\"#flex-布局\" class=\"headerlink\" title=\"flex 布局\"></a>flex 布局</h1><h3 id=\"1-按比例分区\"><a href=\"#1-按比例分区\" class=\"headerlink\" title=\"1. 按比例分区\"></a>1. 按比例分区</h3><ul>\n<li><p>填满区域(可以用于全屏幕布局场景)</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flex:1</span><br></pre></td></tr></table></figure></li>\n<li><p>按比例分区</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">css:&#123;</span><br><span class=\"line\">.box1:&#123;</span><br><span class=\"line\">\tflex:3</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">.box2:&#123;</span><br><span class=\"line\">\tflex:5</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">.box3:&#123;</span><br><span class=\"line\">\tflex:3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 按照父元素块的大小分割 3:5:3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-flex-direction\"><a href=\"#2-flex-direction\" class=\"headerlink\" title=\"2. flex-direction\"></a>2. flex-direction</h3><ul>\n<li><p>决定布局的主轴 默认值为<strong>竖直轴（column）</strong>方向,<strong>水平轴为row</strong></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flex-direction: row;</span><br><span class=\"line\">flex-direction: column;</span><br></pre></td></tr></table></figure>\n\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429192009.png\" alt=\"colum\"></p>\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191936.png\" alt=\"row\"></p>\n</li>\n<li><p><code>justifyContent</code>决定其子元素沿主轴的排列方式</p>\n</li>\n<li><p><code>alignItem</code>决定其子元素沿此轴的排列方式</p>\n</li>\n<li><p>排列方式已主轴默认column为例</p>\n<ul>\n<li><p>flex-start</p>\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191934.png\" alt=\"image-20210429185938115\"></p>\n</li>\n<li><p>flex-end</p>\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191932.png\" alt=\"image-20210429185959461\"></p>\n</li>\n<li><p>center</p>\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191928.png\" alt=\"image-20210429190020934\"></p>\n</li>\n<li><p>space-between</p>\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191927.png\" alt=\"image-20210429190058289\"></p>\n</li>\n<li><p>space-around</p>\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191921.png\" alt=\"image-20210429190215098\"></p>\n</li>\n<li><p>space-evenly</p>\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191918.png\" alt=\"image-2\"></p>\n</li>\n</ul>\n</li>\n<li><p><code>alignSelf</code>在父级元素下不影响其他子项的情况进行单个的排列方式</p>\n<ul>\n<li><p>stretch</p>\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429192711.png\" alt=\"image-20210429190718573\"></p>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["CSS"],"tags":["react-native"]},{"title":"ES6 symbol对象","url":"/2021/04/27/symbol%E5%AF%B9%E8%B1%A1/","content":"<p>ES6新增数据类型 Symbol（符号） 类型</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Symbol（符号）-类型\"><a href=\"#Symbol（符号）-类型\" class=\"headerlink\" title=\"Symbol（符号） 类型\"></a>Symbol（符号） 类型</h1><h3 id=\"1-使用场景\"><a href=\"#1-使用场景\" class=\"headerlink\" title=\"1. 使用场景\"></a>1. 使用场景</h3><ul>\n<li>确保对象属性的使用的<strong>唯一标识符</strong></li>\n<li>创建唯一记号，用作非字符串形式的对象属性</li>\n</ul>\n<h3 id=\"2-声明定义方式\"><a href=\"#2-声明定义方式\" class=\"headerlink\" title=\"2. 声明定义方式\"></a>2. 声明定义方式</h3><ul>\n<li><p>常规</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\">let hh = Symbol(&#x27;你好&#x27;);</span><br><span class=\"line\">let edu = Symbol(&#x27;你好&#x27;);</span><br><span class=\"line\">// ‘’ 里面写描述</span><br><span class=\"line\">console.log(hh == edu)</span><br><span class=\"line\">console.log(hh)</span><br><span class=\"line\">console.log(hh.description) // 输出描述</span><br><span class=\"line\">/*</span><br><span class=\"line\">false</span><br><span class=\"line\">Symbol(你好)</span><br><span class=\"line\">你好</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></li>\n<li><p>symbol.for 定义全局注册表,并记录在内存中（运行时的不同部分需要共享和重用符号实例）</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let com = Symbol.for(&#x27;hh&#x27;)</span><br><span class=\"line\">    let mmm = Symbol.for(&#x27;hh&#x27;)</span><br><span class=\"line\">    console.log(com == mmm)</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    true</span><br><span class=\"line\">    */</span><br></pre></td></tr></table></figure></li>\n<li><p>symbol.keyFor()查询<strong>全局注册表</strong></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\\\ 全局</span><br><span class=\"line\">let s = symbol.for(&#x27;hh&#x27;)</span><br><span class=\"line\">symbol.keyFor(s)  // hh</span><br><span class=\"line\"></span><br><span class=\"line\">\\\\ 普通</span><br><span class=\"line\">let s = symbol(&#x27;hh&#x27;)</span><br><span class=\"line\">symbol.keyFor(s)  // undefined</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"3-解决字符串耦合问题\"><a href=\"#3-解决字符串耦合问题\" class=\"headerlink\" title=\"3. 解决字符串耦合问题\"></a>3. 解决字符串耦合问题</h3><ul>\n<li><p>声明时，key相同，数据不会重复显示</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let hh =&#123;</span><br><span class=\"line\">    song:&#123;js:100 , css :50&#125;,</span><br><span class=\"line\">    song:&#123;js:60 , css:100&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(hh)</span><br></pre></td></tr></table></figure>\n\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/image-20210428092009035.png\" alt=\"image-20210428092009035\"></p>\n</li>\n<li><p>声明时加上symbol</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> let user1 =&#123;</span><br><span class=\"line\">        name:&#x27;song&#x27;,</span><br><span class=\"line\">        key:Symbol(&#x27;song&#x27;)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    let user2 =&#123;</span><br><span class=\"line\">        name:&#x27;song&#x27;,</span><br><span class=\"line\">        key:Symbol(&#x27;song&#x27;)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">let hh =&#123;</span><br><span class=\"line\">    [user1.key]:&#123;js:100 , css :50&#125;,</span><br><span class=\"line\">    [user2.key]:&#123;js:60 , css:100&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(hh);</span><br></pre></td></tr></table></figure>\n\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/image-20210428092714562.png\" alt=\"image-20210428092714562\"></p>\n</li>\n</ul>\n","categories":["ES6"],"tags":["Symbol"]},{"title":"websocket","url":"/2022/01/11/websocket/","content":"<p>websocket 诞生的原因 以及特点</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Websocket-基础\"><a href=\"#Websocket-基础\" class=\"headerlink\" title=\"Websocket 基础\"></a>Websocket 基础</h1><ul>\n<li><p>Websocket 诞生的原因是 ， http协议之下 ， 通信只能由客户端发起 ， 对于服务器有连续的状态变化，客户端要获知就非常麻烦 （只能轮询 每隔一段时间 发出一种请求） ， 效率低 ， 非常浪费资源</p>\n</li>\n<li><p>websocket诞生 –》 <strong>全双工通信</strong> 相比于  半双工通信 ， 服务端 客户端 都可以主动推送信息</p>\n</li>\n<li><p>Websocket 是</p>\n<p>  浏览器与服务器进行全双工通信</p>\n<p>  的网络技术 </p>\n<ul>\n<li>特点<ul>\n<li>基于tcp 复用http的握手通道</li>\n<li>只需完成一次握手就可以创建持久性连接 </li>\n<li>支持双向通信 ， 实时性更强</li>\n<li>数据格式轻量 ， 通信高效</li>\n<li>可以发送文本 也可以发送二进制</li>\n<li>协议标识符为ws 加密 wss</li>\n<li>没有同源策略 ， 客户端可以跟任意服务端通信</li>\n<li>与http有良好的兼容性 ， 握手阶段采用http协议，可以通过各种代理服务器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用方法</p>\n<ul>\n<li>创建实例<ul>\n<li>Let ws = new Websocket(‘ws://localhost:9999’);</li>\n</ul>\n</li>\n<li>建立连接时触发<ul>\n<li>ws.onopen = () =&gt;{}</li>\n</ul>\n</li>\n<li>服务端给客户端发来消息时触发<ul>\n<li>ws.onmessage = (res) =&gt;{console.log(res)}</li>\n</ul>\n</li>\n<li>断开连接时触发<ul>\n<li>ws.onclose = function (){}</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机网络"],"tags":["websocket"]},{"title":"变量、作用域与内存'","url":"/2021/05/04/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/","content":"<p>JavaScript 变量、作用域与内存</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、变量（松散类型，值和数据类型可以在生命周期中改变）\"><a href=\"#一、变量（松散类型，值和数据类型可以在生命周期中改变）\" class=\"headerlink\" title=\"一、变量（松散类型，值和数据类型可以在生命周期中改变）\"></a>一、变量（松散类型，值和数据类型可以在生命周期中改变）</h2><ul>\n<li><p> <strong>原始值</strong> <strong>引用值</strong></p>\n</li>\n<li><p> 原始值最简单的<strong>数据</strong> ，例如数据类型：Undefined  Null  Boolean  Number  String  Symbol </p>\n</li>\n<li><p> 引用值是多个值构成的<strong>对象</strong></p>\n</li>\n<li><p> 原始值是按<strong>值</strong>访问的，我们操作的就是存储在变量中的实际值</p>\n</li>\n<li><p> 引用值是按<strong>引用</strong>访问的，我们操作的也是引用</p>\n</li>\n<li><p>动态属性</p>\n<ul>\n<li><p>引用值可以随时添加修改和删除属性，原始值没有属性</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let name = &#x27;hh&#x27;;</span><br><span class=\"line\">name.sex = &#x27;girl&#x27;;</span><br><span class=\"line\">console.log(name.sex); // ==》 Undefined</span><br><span class=\"line\"></span><br><span class=\"line\">let name = new String(&#x27;hh&#x27;);</span><br><span class=\"line\">name.sex = &#x27;girl&#x27;;</span><br><span class=\"line\">console.log(name.sex) ; // ==》 girl</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>复制值</strong></p>\n<ol>\n<li><p>原始值复制值 ， 栈内存中增加了一个值</p>\n<p> <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210504143324.PNG\" alt=\"IMG_0040(20210504-142902)\"></p>\n</li>\n<li><p>引用值复制指针，堆内存中未增加值，增加了一个指针</p>\n<p> <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210504143344.PNG\" alt=\"IMG_0041(20210504-142917)\"></p>\n</li>\n</ol>\n</li>\n<li><p><strong>传参</strong></p>\n<ol>\n<li><p>按值传递参数时，值会复制到一个局部变量，局部变量的改变并不能引起原值的改变</p>\n</li>\n<li><p>传递对象时，函数内部和函数外部对象都指向同一个对象，因此要发生改变。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let sword = new String();</span><br><span class=\"line\">sword.name = &#x27;sss&#x27;;</span><br><span class=\"line\">function hh (nm) &#123;</span><br><span class=\"line\">    nm.name = &#x27;sword&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(sword);</span><br><span class=\"line\">hh(sword);</span><br><span class=\"line\">console.log(sword);</span><br></pre></td></tr></table></figure>\n\n<p> <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210504160714.png\" alt=\"image-20210504160714907\"></p>\n</li>\n</ol>\n</li>\n<li><p><strong>确定类型</strong></p>\n<ol>\n<li><p> <code>typeof</code> 用来确定是什么类型的数据，对于原始值来说相对友好，对于引用值来说，只能返回对象</p>\n</li>\n<li><p>我们通常想要的是返回何种类型的对象，这是我们引入 <code>instanceof</code> </p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log( colors instanceof Array);   ==》 true 数组对象 false 非</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"二、执行上下文与作用域\"><a href=\"#二、执行上下文与作用域\" class=\"headerlink\" title=\"二、执行上下文与作用域\"></a>二、执行上下文与作用域</h2><h4 id=\"上下文\"><a href=\"#上下文\" class=\"headerlink\" title=\"上下文\"></a>上下文</h4><ol>\n<li>上下文决定了变量和函数可以<strong>访问哪些数据</strong></li>\n<li>每个上下文都有一个<strong>变量对象</strong>，而这个上下文中定义的全部变量和函数都存在于这个变量中</li>\n<li>全局上下文是最外层的上下文 （定义的全局变量位于其中，联系到var 中的<strong>变量提升</strong>）</li>\n<li>上下文在其所有代码执行完之后才会被销毁，全局上下文最后才会被销毁，比如关闭网页</li>\n<li>上下文栈控制程序的执行流</li>\n</ol>\n<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><ul>\n<li><p>决定了上下文的<strong>代码在访问函数或变量的顺序</strong> ， 全局上下文的变量对象始终是作用域链的最后一个变量对象（一直可以被找到，并且最后一个销毁）</p>\n</li>\n<li><p>代码在执行时，沿作用域链逐级搜索标识名称。顺序：从作用链的最前端搜索，逐级搜索（就近原则）</p>\n<p>  <img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210504164248.png\" alt=\"1E702811928957DBEE7CCCB804567863\"></p>\n<ul>\n<li>内部可以访问外部 但是外部不可以访问内部</li>\n</ul>\n</li>\n<li><p>作用域链增强 （在作用链前端临时添加一个上下文，代码执行后便删除）</p>\n<ul>\n<li>try / catch 语句</li>\n<li>with 语句</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h4><ul>\n<li>var <ul>\n<li>自动添加到最接近的上下文</li>\n<li>拿到函数或全局作用域的顶部（作用域链的尾部） ===》 变量提升</li>\n</ul>\n</li>\n<li>let<ul>\n<li>块级作用域</li>\n<li>同一作用域不能声明两次 声明后的变量，值可以改变</li>\n<li>由于“暂时性死区” ， （变量声明之前无法引用） ， let 也会被提升，不过跟var的变量提升有本质的不同</li>\n</ul>\n</li>\n<li>const<ul>\n<li>块级作用域</li>\n<li>不能重新赋值</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三、垃圾回收\"><a href=\"#三、垃圾回收\" class=\"headerlink\" title=\"三、垃圾回收\"></a>三、垃圾回收</h2><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><ul>\n<li>自动内存管理实现内存分配和闲置资源回收</li>\n<li>基本思路：周期性的确定哪个变量不会再使用，然后释放它的内存。</li>\n<li>常用办法：<strong>标记清理</strong> 、 引用计数 </li>\n</ul>\n<h4 id=\"标记清理\"><a href=\"#标记清理\" class=\"headerlink\" title=\"标记清理\"></a>标记清理</h4><ul>\n<li>标记内存中的所有变量</li>\n<li>去掉所有在上下文中的变量以及上下文引用的变量的标记</li>\n<li>剩下的就是不使用的变量 回收</li>\n</ul>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><ul>\n<li>减少垃圾回收的次数</li>\n<li>动态改变垃圾回收的阈值</li>\n</ul>\n<h2 id=\"四、内存管理\"><a href=\"#四、内存管理\" class=\"headerlink\" title=\"四、内存管理\"></a>四、内存管理</h2><ul>\n<li>优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据</li>\n<li>数据不再使用，可以把他设置为 <code>null</code> ,释放引用。垃圾回收时会被回收</li>\n</ul>\n<h4 id=\"通过const-let-声明提升性能\"><a href=\"#通过const-let-声明提升性能\" class=\"headerlink\" title=\"通过const let 声明提升性能\"></a>通过const let 声明提升性能</h4><ul>\n<li>块作用域，可以更早的垃圾回收</li>\n</ul>\n<h4 id=\"隐藏类和删除操作\"><a href=\"#隐藏类和删除操作\" class=\"headerlink\" title=\"隐藏类和删除操作\"></a>隐藏类和删除操作</h4><h4 id=\"内存泄漏（闭包）\"><a href=\"#内存泄漏（闭包）\" class=\"headerlink\" title=\"内存泄漏（闭包）\"></a>内存泄漏（闭包）</h4><h4 id=\"静态分配与对象池\"><a href=\"#静态分配与对象池\" class=\"headerlink\" title=\"静态分配与对象池\"></a>静态分配与对象池</h4>","categories":["JavaScript"],"tags":["变量、作用域与内存"]},{"title":"如何解决前后端跨域问题（详细）","url":"/2021/09/01/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%89%8D%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89/","content":"<p>从为什么跨域 如何解决跨域 讲到 token cookie 的爱恨情仇</p>\n<span id=\"more\"></span>\n\n<h1 id=\"如何解决前后端跨域问题（详细）\"><a href=\"#如何解决前后端跨域问题（详细）\" class=\"headerlink\" title=\"如何解决前后端跨域问题（详细）\"></a>如何解决前后端跨域问题（详细）</h1><h3 id=\"一、经典疑问：为什么会跨域？\"><a href=\"#一、经典疑问：为什么会跨域？\" class=\"headerlink\" title=\"一、经典疑问：为什么会跨域？\"></a>一、经典疑问：为什么会跨域？</h3><p>我们把问题分解 </p>\n<ul>\n<li><p>谁出现的跨域？  ==》 <strong>浏览器！</strong></p>\n</li>\n<li><p>为何出现？ ==》 同源策略</p>\n<ul>\n<li>同源策略？<ul>\n<li>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS</code>、<code>CSFR</code>等攻击。</li>\n<li>所谓同源 ==》指的是 “协议+域名+端口” 三者的相同 只要有一个不同就会导致跨域问题</li>\n</ul>\n</li>\n<li>目的：简单来说就是禁止的是来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。</li>\n</ul>\n</li>\n<li><p>解决方案？</p>\n<ul>\n<li><p>前端做代理服务器</p>\n</li>\n<li><p>跨域技术-<code>CORS</code> （<code>CrossOrigin Resources Sharing</code>，跨源资源共享）<strong>（推荐）</strong></p>\n<ul>\n<li><code>CORS</code>，是 <code>HTML5</code> 的一项特性，它定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。</li>\n<li>使用原理：浏览器一旦发现 axios 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。 服务器根据这些附加的值，决定是否同意此次请求。</li>\n</ul>\n</li>\n<li><p><code>JSONP</code></p>\n<ul>\n<li><p>改变请求方式  <code>dataType: &#39;jsonp&#39;, // 请求方式为jsonp</code></p>\n</li>\n<li><p>原理： JSONP 是通过动态添加<script>标签来调用服务器的脚本（<script>含有src属性，src属性没有跨域限制）；而 Ajax 是通过 XHR(XmlHttpRequest) 对象。</p>\n</li>\n<li><p>```<br>  // 前端实现<br>  $.ajax({<br>  url: ‘<a href=\"http://www.domain2.com:8080/login&#39;\">http://www.domain2.com:8080/login&#39;</a>,<br>  type: ‘get’,<br>  dataType: ‘jsonp’, // 请求方式为jsonp<br>  jsonpCallback: “onBack”, // 自定义回调函数名<br>  data: {}<br>  });</p>\n<p>  // 后台实现<br>  @ControllerAdvice(basePackages = “com.zkn.learnspringboot.web.controller”)<br>  public class JsonpAdvice extends AbstractJsonpResponseBodyAdvice{</p>\n<p>  public JsonpAdvice() {</p>\n<p>  super(“callback”,”jsonp”);<br>  }<br>  }</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 解决最优解  ==》 `CORS`</span><br><span class=\"line\"></span><br><span class=\"line\">    - 相比于 `jsonp` 只能用于get 请求来说  `cors`对于所有的请求都通用</span><br><span class=\"line\">    - `jsonp` 的优势在于可以在于支持老式浏览器，以及可以向不支持 `cors` 的网站请求数据。</span><br><span class=\"line\"></span><br><span class=\"line\">## 二、如何解决？</span><br><span class=\"line\"></span><br><span class=\"line\">- 前端代理服务器（vue）</span><br><span class=\"line\"></span><br><span class=\"line\">    - vue.config.js  ==&gt; 配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">        - ```</span><br><span class=\"line\">            // 配置代理</span><br><span class=\"line\">                devServer: &#123;</span><br><span class=\"line\">                    port: 9086,</span><br><span class=\"line\">                    open: false,</span><br><span class=\"line\">                    overlay: &#123;</span><br><span class=\"line\">                        warnings: false,</span><br><span class=\"line\">                        errors: true</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    proxy: &#123;</span><br><span class=\"line\">                        &quot;/dev_api&quot;: &#123;</span><br><span class=\"line\">                            target: &quot;http://11.111.111.11:8000/&quot;, ==》 此处写明自己应该访问的代码</span><br><span class=\"line\">                            changeOrigin: true,</span><br><span class=\"line\">                            pathRewrite: &#123;</span><br><span class=\"line\">                                &quot;^/dev_api&quot;: &quot;&quot;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>request.js 中配置baseUrl</p>\n<ul>\n<li><p>```<br>  let instance = axios.create({</p>\n<pre><code>  baseURL: &quot;/dev_api&quot;,\n  withCredentials: true, // send cookies when cross-domain requests\n  timeout:5000,\n</code></pre>\n<p>  })<br>  // 注意： dev_api 之前的 “/” 一定不可省略 别问我为啥知道的<br>  // 此处的dev_api 要与上面的相对应 当然 也可以起自己的名字</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    - 本地运行比较顺畅 ， 但是项目打包到服务器 就需要对地址进行一个调试了 ，跟后台协调好！</span><br><span class=\"line\"></span><br><span class=\"line\">- 跨域技术-`CORS` **(推荐)**</span><br><span class=\"line\"></span><br><span class=\"line\">    - 简介</span><br><span class=\"line\"></span><br><span class=\"line\">        - CORS 通信过程都是浏览器自动完成的 不需要用户参与</span><br><span class=\"line\">        - 对于开发者一样，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息</span><br><span class=\"line\">        - 因此 实现CORS的关键是服务器，只要服务器实现了CORS接口 就可以跨域通信</span><br><span class=\"line\"></span><br><span class=\"line\">    - 简单请求（get post）</span><br><span class=\"line\"></span><br><span class=\"line\">        - 当浏览器发现跨域之后，就会向请求头信息里面自动添加一个`Origin`字段</span><br><span class=\"line\"></span><br><span class=\"line\">            - ```</span><br><span class=\"line\">                GET /cors HTTP/1.1</span><br><span class=\"line\">                Origin: http://api.bob.com</span><br><span class=\"line\">                Host: api.alice.com</span><br><span class=\"line\">                Accept-Language: en-US</span><br><span class=\"line\">                Connection: keep-alive</span><br><span class=\"line\">                User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Origin</code>字段说明了本次请求来自哪个域（协议+域名+端口）</li>\n</ul>\n</li>\n<li><p>如果发现 <code>Origin</code>为指定的源 （白名单中），服务器会响应成功，并在响应头中多几个信息字段</p>\n<ul>\n<li>```<br>  // 该字段是必须的 该字段要么 * 要么 是请求时 Origin 中的值<br>  Access-Control-Allow-Origin: <a href=\"http://api.bob.com/\">http://api.bob.com</a>    // 该字段可选 是否允许发送cookie<br>  Access-Control-Allow-Credentials: true  /* CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个服务器返回的基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。*/  Access-Control-Expose-Headers: FooBar  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    - 如果发现 `Origin`不在许可的范围内，服务器会返回一个正常的Http回应，并且抛出错误 XMLHttpRequest...</span><br><span class=\"line\"></span><br><span class=\"line\">- 如何配置？</span><br><span class=\"line\"></span><br><span class=\"line\">    - 前面已经说到实现CORS的关键是服务端 因此前端只需要配置**`withCredentials`** 属性</span><br><span class=\"line\"></span><br><span class=\"line\">    - CROS 请求默认不包含 cookie 信息  如果我们想要包含就必须在请求中将 **`withCredentials`** 属性 配置为 `true`</span><br><span class=\"line\"></span><br><span class=\"line\">        - ```</span><br><span class=\"line\">            // 创建axios 实例  ===&gt; 代理服务器一定要写/!!!!</span><br><span class=\"line\">            let instance = axios.create(&#123;</span><br><span class=\"line\">                baseURL: &quot;/dev_api&quot;,</span><br><span class=\"line\">                withCredentials: true, // send cookies when cross-domain requests</span><br><span class=\"line\">                timeout:5000,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            </span><br><span class=\"line\">            instance.defaults.withCredentials = true;  //允许携带cookie   ==&gt; 这个太关键</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>同样 需要注意的是 如果要发送cookie  <code>Access-Control-Allow-Origin</code>就不可以设置为 ***** ！！ 也就意味这<strong>必须指定明确的、与请求网页一致的域名</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三、Token-、Cookie-与-CORS-的爱恨情仇\"><a href=\"#三、Token-、Cookie-与-CORS-的爱恨情仇\" class=\"headerlink\" title=\"三、Token 、Cookie 与 CORS 的爱恨情仇\"></a>三、Token 、Cookie 与 CORS 的爱恨情仇</h2><ul>\n<li><p>用户验证何来？</p>\n<ul>\n<li>众所周知，当客户端多次向服务端请求数据时，服务端就需要多次从数据库中查询用户名和密码并进行对比，判断用户名和密码是否正确，并作出相应提示。</li>\n<li>但这样无疑会增加服务器端的运行压力，是否可以有一种方式只需要验证用户就是之前的用户而不需要每次在客户端请求数据时都需要查询数据库判断用户名和密码是否正确。</li>\n<li>就这样 为了避免大量的查询数据库 减小服务器端的运行压力 令牌机制应运而生</li>\n</ul>\n</li>\n<li><p>令牌如何运作？</p>\n<ul>\n<li><p>token</p>\n<ul>\n<li><p>前端登录成功后 后台返回token</p>\n</li>\n<li><p>前端要对token 进行处理 存储并放到请求头中 每次请求都会将token 放入 请求头中</p>\n<ul>\n<li>```<br>  instance.interceptors.request.use(<pre><code>(config) =&gt; &#123;\n  // 判断某些接口不需要token\n  if (!config.noAuthorization) &#123;\n    // 加入token\n    let token = RootStore.userStore.allData.accessToken;\n    if (token) &#123;\n      config.headers.Authorization = `Bearer $&#123;token&#125;`;\n    &#125;\n  &#125;\n  return config;\n&#125;,\n(err) =&gt; &#123;\n  console.log(err);\n&#125;,\n</code></pre>\n  );  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">                </span><br><span class=\"line\"></span><br><span class=\"line\">    - cookie 中存储</span><br><span class=\"line\"></span><br><span class=\"line\">        - 后端将令牌(sessionId) 存到浏览器的Cookie 中 </span><br><span class=\"line\">        - 前端请求自动从cookie 将sessionId 传到后端</span><br><span class=\"line\">            - ![image-20210910223347774](https://gitee.com/song-zejian/markdown_image/raw/master/img/20210910223354.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- 当 token cookie 遇到跨域 🤦‍</span><br><span class=\"line\"></span><br><span class=\"line\">    - token</span><br><span class=\"line\"></span><br><span class=\"line\">        - 跨域了？ 我们可以直接在服务端 `Access-Control-Allow-Origin`就设置为 *****  前端 `withCredentials`属性为 `false`</span><br><span class=\"line\">        - 也就是说 允许所有的 origin 访问</span><br><span class=\"line\"></span><br><span class=\"line\">    - cookie</span><br><span class=\"line\"></span><br><span class=\"line\">        - 理论上 我们可以遵循token的方法进项解决，但</span><br><span class=\"line\"></span><br><span class=\"line\">        - 上文所说 ==》需要注意的是 如果要发送cookie  `Access-Control-Allow-Origin`就不可以设置为 ***** ！！ 也就意味这**必须指定明确的、与请求网页一致的域名**</span><br><span class=\"line\"></span><br><span class=\"line\">        - 也就意味这 ，我们需要指定明确的 域名 进行访问  并且要告诉后端 我们的的域名是什么，并让他加入白名单中</span><br><span class=\"line\"></span><br><span class=\"line\">        - 最重要的 我们要在前端配置**`withCredentials`** 属性 配置为 `true`</span><br><span class=\"line\"></span><br><span class=\"line\">            - ```</span><br><span class=\"line\">                // 创建axios 实例  ===&gt; 代理服务器一定要写/!!!!</span><br><span class=\"line\">                let instance = axios.create(&#123;</span><br><span class=\"line\">                    baseURL: &quot;/dev_api&quot;,</span><br><span class=\"line\">                    withCredentials: true, // send cookies when cross-domain requests</span><br><span class=\"line\">                    timeout:5000,</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                </span><br><span class=\"line\">                instance.defaults.withCredentials = true;  //允许携带cookie   ==&gt; 这个太关键</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>同时在后端配置 <code>access-Control-Allow-Credentials</code> 为 <code>true</code></p>\n<ul>\n<li><img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210910224414.png\" alt=\"2021910-224358\"></li>\n</ul>\n</li>\n<li><p>这样在 所给的的origin url之下 我们就可以实现登录 并解决跨域</p>\n</li>\n<li><p>小问题</p>\n<ul>\n<li>只有用浏览器访问服务器地址下的路径，浏览器才会自动带上cookies，那么我们本地调试带不上cookie怎么办？<ul>\n<li>方案一： 利用服务器代理 ==》 利用上述服务器代理解决跨域的问题<ul>\n<li>缺点：但是上服务器的时候需要进行修改 baseURL</li>\n</ul>\n</li>\n<li>方案二：利用服务器上已经传入的sessionId 对本地进行写入  ==&gt; 控制台 <ul>\n<li>没有的话进行写入</li>\n<li><img src=\"https://gitee.com/song-zejian/markdown_image/raw/master/img/20210910225423.png\" alt=\"image-20210910225423053\"></li>\n<li>缺点：sessionId 更新时间较短不适用  需要频繁的修改写入 sesionId</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>总结</p>\n<ul>\n<li>由篇幅量可得，token 比 cookie 便捷  事实也是 cookies有很多限制和麻烦 就导致比较的麻烦</li>\n<li>对于安全性来讲：并不是麻烦了安全 两者都是用令牌进行传送 ，只不过方式不一样 ，安全性还是差不多的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["跨域问题"],"tags":["跨域"]},{"title":"2021  7.25 -- 9.3 暑期实习复盘","url":"/2022/01/11/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>总结 启发 奋斗 </p>\n<span id=\"more\"></span>\n\n<h1 id=\"2021-7-25-–-9-3-实习总结\"><a href=\"#2021-7-25-–-9-3-实习总结\" class=\"headerlink\" title=\"2021  7.25 – 9.3 实习总结\"></a>2021  7.25 – 9.3 实习总结</h1><h4 id=\"实习结果：\"><a href=\"#实习结果：\" class=\"headerlink\" title=\"实习结果：\"></a>实习结果：</h4><p>完成大家影像后台管理系统 、 影像前台系统 的前端开发 </p>\n<h4 id=\"实习收获：\"><a href=\"#实习收获：\" class=\"headerlink\" title=\"实习收获：\"></a>实习收获：</h4><ul>\n<li><p>了解整个项目的制作流程 </p>\n<ul>\n<li>需求==》设计==》开发==》测试==》展示  五个阶段 </li>\n<li>每一个阶段都在为下一个阶段做铺垫 ， 想要做好项目 ，必须稳扎稳打，把每一步都做好！</li>\n</ul>\n</li>\n<li><p>熟悉 vue 全家桶+ element 协作开发</p>\n<ul>\n<li>涉及到 vuex 、axios 、浏览器缓存等细节的把握</li>\n<li>更深入了解到登录令牌 （token）、路由守卫如何应用</li>\n</ul>\n</li>\n<li><p>了解一个项目如何切实的推进</p>\n<ul>\n<li>各个阶段所需的文档肯定是必不可少 ， 增加项目的可维护性</li>\n<li>符合实际的规划，有目的有计划的进行项目开发</li>\n</ul>\n</li>\n<li><p>认识到许多志同道合的小伙伴 ，协同一起努力学习</p>\n</li>\n<li><p>感受在职场中的氛围、节奏，了解未来的生活，感觉还是不错的</p>\n</li>\n</ul>\n<h4 id=\"企业建议：\"><a href=\"#企业建议：\" class=\"headerlink\" title=\"企业建议：\"></a>企业建议：</h4><ul>\n<li>对学生进行针对性的培养，因为每个学生的学习情况，学习方向都有所不同。</li>\n<li>将学生切实的投入项目的实战当中去</li>\n</ul>\n","categories":["复盘"],"tags":["暑期实习"]},{"title":"字节跳动国际化社区一面面经","url":"/2022/01/11/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9B%BD%E9%99%85%E5%8C%96%E7%A4%BE%E5%8C%BA%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/","content":"<p>一面过了！！感谢一面大大 ， 努力总会有收获的！加油</p>\n<span id=\"more\"></span> \n\n<h1 id=\"字节跳动国际化社区（一面）-（50min）\"><a href=\"#字节跳动国际化社区（一面）-（50min）\" class=\"headerlink\" title=\"字节跳动国际化社区（一面） （50min）\"></a>字节跳动国际化社区（一面） （50min）</h1><ol>\n<li>自我介绍 一分20秒</li>\n<li>看的书籍是什么？</li>\n<li>问项目<ol>\n<li>大家保险业务是什么？</li>\n<li>如何验证一个用户是登录用户？<ol>\n<li>Token cookie 是否过期 </li>\n</ol>\n</li>\n<li>Token 如何产生的呢？<ol>\n<li>服务端如何产生Token？<ol>\n<li>服务端产生的密匙 ， 用来维持校验登陆状态</li>\n</ol>\n</li>\n<li>cookie和session的区别<ol>\n<li><a href=\"https://www.zhihu.com/question/19786827\">COOKIE和SESSION有什么区别？ - 知乎 (zhihu.com)</a></li>\n<li>由于http是无状态的协议 ， 服务端需要记录状态由此生成session ，类似于会话 ， 用于跟踪用户状态 （特点 ： 服务端保存 ， 用于记录用户状态）</li>\n<li>Cookie ， 识别特定的用户 ，客户端保存 ， 客户端在请求时会把相应的cookie信息发送至服务端。（利用cookie实现session的跟踪 ， 在cookie存一个sessionid ， 每次请求通过寻找这个id）</li>\n<li>如果禁用cookie？ 使用一种URL重写的技术 进行会话跟踪（在url后附上参数）</li>\n<li>总结： <ol>\n<li>session ： 保存在服务端 ， 用开记录用户的状态</li>\n<li>cookie：保存在客户端 ， 用来识别特定的用户 ， 常用cookie来实现session的跟踪</li>\n</ol>\n</li>\n<li>cookie是如何产生的呢？<ol>\n<li>cookie是服务生成发给客户端并保存在本地的一小块数据 ， 他会在浏览器发出请求时被携带并发送到服务器上</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Vue  路由守卫如何实现的呢？ 是什么？<ol>\n<li>全局前置路由守卫 全局后置路由守卫 组件内的路由守卫 keep-alive 缓存组件内部的状态 避免重新渲染</li>\n</ol>\n</li>\n<li>Vue 组件如何通信？<ol>\n<li>父子组件通信<a href=\"https://wfx7jb3ja4.feishu.cn/docs/doccn0HTuqYRcjKLncnzxqfmamh#\">Vue框架的知识</a> </li>\n</ol>\n</li>\n<li>Vue双向绑定实现原理？<ol>\n<li>vue框架</li>\n</ol>\n</li>\n<li>JavaScript数据类型</li>\n<li>js变量回收的循环引用</li>\n<li>说一下ES5中实现继承</li>\n<li>原型链 ， 原型链最终的指向？</li>\n<li>编程题输出</li>\n<li>HTML语义化</li>\n<li>网络<ol>\n<li>强缓存和协商缓存<ol>\n<li>标识 如何知道缓存了 如何知道过期了</li>\n</ol>\n</li>\n<li>Http 1 2 不同</li>\n<li>Http 3</li>\n<li>webScoket</li>\n</ol>\n</li>\n<li>参数比较编程题 <ol>\n<li>String string 值一样返回true  Object Object 返回true  function function 都是声明的一个新的变量 返回false</li>\n</ol>\n</li>\n</ol>\n","categories":["面经"],"tags":["字节面经"]},{"title":"终身学习","url":"/2021/04/20/%E7%BB%88%E8%BA%AB%E5%AD%A6%E4%B9%A0/","content":"<p> 改变也许艰难，却从未有人说过不值得</p>\n<span id=\"more\"></span>\n\n<h1 id=\"《终身成长》\"><a href=\"#《终身成长》\" class=\"headerlink\" title=\"《终身成长》\"></a>《终身成长》</h1><h6 id=\"成长是一辈子的事儿-，-他无关年纪。\"><a href=\"#成长是一辈子的事儿-，-他无关年纪。\" class=\"headerlink\" title=\"成长是一辈子的事儿 ， 他无关年纪。\"></a>成长是一辈子的事儿 ， 他无关年纪。</h6><h6 id=\"无论何时，停止成长，才是最可怕的衰老\"><a href=\"#无论何时，停止成长，才是最可怕的衰老\" class=\"headerlink\" title=\"无论何时，停止成长，才是最可怕的衰老\"></a>无论何时，停止成长，才是最可怕的衰老</h6><p>从这本书中，收获最大的是</p>\n<h5 id=\"谦逊\"><a href=\"#谦逊\" class=\"headerlink\" title=\"谦逊\"></a>谦逊</h5><p>典型的<strong>固定型思维</strong>的人认为人的才能是一成不变的。在日常的行为举止中，时刻想要证明自己的智力、个性和特征。他们把发生的事情当作衡量能力和价值的直接标尺。</p>\n<p>你有没有中招啊？</p>\n<p>而<strong>成长性思维</strong>的人认为，人的能力是可以努力培养的。虽然人的先天才能、性格、资质都各有偏差，但都可以通过努力来改变。</p>\n<p>我们从几个方面来探讨这两个模式</p>\n<ul>\n<li><p>对自身的客观评价</p>\n<p>  固定思维的人都自视甚高，对自己能力评估非好即坏，不免夸大或模糊</p>\n<p>  成长性思维，用发展的眼光看待自己。相信自己可以培养，更加开放的心态来评估自己的现有水平，因此更准确</p>\n</li>\n<li><p>对失败的看法</p>\n<p>  固定型思维，失败是一种行为，一种身份。因此他们无法正确的看待失败，无法接受失败的自己</p>\n<p>  成长型思维，即便失败的痛苦的，但是不能对自己下定义，他只是需要面临和解决的一个问题。从失败和挫折中收益，让自己变得更强大</p>\n</li>\n</ul>\n<p>成长型思维的人能明确目标，不断优化学习方法，并乐于向同伴学习。也就谓之，不摆架子，谦虚向他人学习，同时对于自己的失败以及成功，可以很好的从中受益，并且让自己好好成长。</p>\n<h3 id=\"如何成为成长型思维的人\"><a href=\"#如何成为成长型思维的人\" class=\"headerlink\" title=\"如何成为成长型思维的人\"></a>如何成为成长型思维的人</h3><ul>\n<li><p><strong>接受</strong> </p>\n<p>  每个人多多少少会有固定型思维，当我们发现时，我们不必感到羞愧，我们首先得承认面对他</p>\n</li>\n<li><p><strong>观察</strong></p>\n<p>  观察你的固定型思维人格，明确他出现的原因。</p>\n</li>\n<li><p><strong>命名</strong></p>\n<p>  给自己固定型思维起个名字，用来警醒自己</p>\n</li>\n<li><p><strong>教育</strong></p>\n<p>  用成长型思维模式与他沟通，教育他。</p>\n</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>正如作者所说，改变也许艰难，却未有人说过不值得。</p>\n<p>何况，你我都是对自己有要求的人，不是吗？</p>\n<p><strong>参考：</strong>樊登读书《终身成长》 作者：卡罗尔 德韦克</p>\n","categories":["读书笔记"],"tags":["成长型思维"]}]