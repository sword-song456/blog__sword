<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基本引用类型</title>
    <url>/2021/05/05/%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1>]]></content>
      <categories>
        <category>基础笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局在react-native中的运用</title>
    <url>/2021/04/29/flex%E5%B8%83%E5%B1%80%E5%9C%A8react-native%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h1 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h1><h3 id="1-按比例分区"><a href="#1-按比例分区" class="headerlink" title="1. 按比例分区"></a>1. 按比例分区</h3><ul>
<li><p>填满区域(可以用于全屏幕布局场景)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex:1</span><br></pre></td></tr></table></figure></li>
<li><p>按比例分区</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css:&#123;</span><br><span class="line">.box1:&#123;</span><br><span class="line">	flex:3</span><br><span class="line">&#125;,</span><br><span class="line">.box2:&#123;</span><br><span class="line">	flex:5</span><br><span class="line">&#125;,</span><br><span class="line">.box3:&#123;</span><br><span class="line">	flex:3</span><br><span class="line">&#125;</span><br><span class="line">// 按照父元素块的大小分割 3:5:3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-flex-direction"><a href="#2-flex-direction" class="headerlink" title="2. flex-direction"></a>2. flex-direction</h3><ul>
<li><p>决定布局的主轴 默认值为<strong>竖直轴（column）</strong>方向,<strong>水平轴为row</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-direction: row;</span><br><span class="line">flex-direction: column;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429192009.png" alt="colum"></p>
<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191936.png" alt="row"></p>
</li>
<li><p><code>justifyContent</code>决定其子元素沿主轴的排列方式</p>
</li>
<li><p><code>alignItem</code>决定其子元素沿此轴的排列方式</p>
</li>
<li><p>排列方式已主轴默认column为例</p>
<ul>
<li><p>flex-start</p>
<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191934.png" alt="image-20210429185938115"></p>
</li>
<li><p>flex-end</p>
<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191932.png" alt="image-20210429185959461"></p>
</li>
<li><p>center</p>
<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191928.png" alt="image-20210429190020934"></p>
</li>
<li><p>space-between</p>
<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191927.png" alt="image-20210429190058289"></p>
</li>
<li><p>space-around</p>
<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191921.png" alt="image-20210429190215098"></p>
</li>
<li><p>space-evenly</p>
<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429191918.png" alt="image-2"></p>
</li>
</ul>
</li>
<li><p><code>alignSelf</code>在父级元素下不影响其他子项的情况进行单个的排列方式</p>
<ul>
<li><p>stretch</p>
<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210429192711.png" alt="image-20210429190718573"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>基础笔记</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title>变量、作用域与内存&#39;</title>
    <url>/2021/05/04/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="JavaScript-变量、作用域与内存"><a href="#JavaScript-变量、作用域与内存" class="headerlink" title="JavaScript 变量、作用域与内存"></a>JavaScript 变量、作用域与内存</h1><h2 id="一、变量（松散类型，值和数据类型可以在生命周期中改变）"><a href="#一、变量（松散类型，值和数据类型可以在生命周期中改变）" class="headerlink" title="一、变量（松散类型，值和数据类型可以在生命周期中改变）"></a>一、变量（松散类型，值和数据类型可以在生命周期中改变）</h2><ul>
<li><p> <strong>原始值</strong> <strong>引用值</strong></p>
</li>
<li><p>原始值最简单的<strong>数据</strong> ，例如数据类型：Undefined  Null  Boolean  Number  String  Symbol </p>
</li>
<li><p>引用值是多个值构成的<strong>对象</strong></p>
</li>
<li><p>原始值是按<strong>值</strong>访问的，我们操作的就是存储在变量中的实际值</p>
</li>
<li><p>引用值是按<strong>引用</strong>访问的，我们操作的也是引用</p>
</li>
<li><p>动态属性</p>
<ul>
<li><p>引用值可以随时添加修改和删除属性，原始值没有属性</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = &#x27;hh&#x27;;</span><br><span class="line">name.sex = &#x27;girl&#x27;;</span><br><span class="line">console.log(name.sex); // ==》 Undefined</span><br><span class="line"></span><br><span class="line">let name = new String(&#x27;hh&#x27;);</span><br><span class="line">name.sex = &#x27;girl&#x27;;</span><br><span class="line">console.log(name.sex) ; // ==》 girl</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>复制值</strong></p>
<ol>
<li><p>原始值复制值 ， 栈内存中增加了一个值</p>
<p> <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210504143324.PNG" alt="IMG_0040(20210504-142902)"></p>
</li>
<li><p>引用值复制指针，堆内存中未增加值，增加了一个指针</p>
<p> <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210504143344.PNG" alt="IMG_0041(20210504-142917)"></p>
</li>
</ol>
</li>
<li><p><strong>传参</strong></p>
<ol>
<li><p>按值传递参数时，值会复制到一个局部变量，局部变量的改变并不能引起原值的改变</p>
</li>
<li><p>传递对象时，函数内部和函数外部对象都指向同一个对象，因此要发生改变。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let sword = new String();</span><br><span class="line">sword.name = &#x27;sss&#x27;;</span><br><span class="line">function hh (nm) &#123;</span><br><span class="line">    nm.name = &#x27;sword&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sword);</span><br><span class="line">hh(sword);</span><br><span class="line">console.log(sword);</span><br></pre></td></tr></table></figure>

<p> <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210504160714.png" alt="image-20210504160714907"></p>
</li>
</ol>
</li>
<li><p><strong>确定类型</strong></p>
<ol>
<li><p> <code>typeof</code> 用来确定是什么类型的数据，对于原始值来说相对友好，对于引用值来说，只能返回对象</p>
</li>
<li><p>我们通常想要的是返回何种类型的对象，这是我们引入 <code>instanceof</code> </p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log( colors instanceof Array);   ==》 true 数组对象 false 非</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="二、执行上下文与作用域"><a href="#二、执行上下文与作用域" class="headerlink" title="二、执行上下文与作用域"></a>二、执行上下文与作用域</h2><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><ol>
<li>上下文决定了变量和函数可以<strong>访问哪些数据</strong></li>
<li>每个上下文都有一个<strong>变量对象</strong>，而这个上下文中定义的全部变量和函数都存在于这个变量中</li>
<li>全局上下文是最外层的上下文 （定义的全局变量位于其中，联系到var 中的<strong>变量提升</strong>）</li>
<li>上下文在其所有代码执行完之后才会被销毁，全局上下文最后才会被销毁，比如关闭网页</li>
<li>上下文栈控制程序的执行流</li>
</ol>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><ul>
<li><p>决定了上下文的<strong>代码在访问函数或变量的顺序</strong> ， 全局上下文的变量对象始终是作用域链的最后一个变量对象（一直可以被找到，并且最后一个销毁）</p>
</li>
<li><p>代码在执行时，沿作用域链逐级搜索标识名称。顺序：从作用链的最前端搜索，逐级搜索（就近原则）</p>
<p>  <img src="https://gitee.com/song-zejian/markdown_image/raw/master/img/20210504164248.png" alt="1E702811928957DBEE7CCCB804567863"></p>
<ul>
<li>内部可以访问外部 但是外部不可以访问内部</li>
</ul>
</li>
<li><p>作用域链增强 （在作用链前端临时添加一个上下文，代码执行后便删除）</p>
<ul>
<li>try / catch 语句</li>
<li>with 语句</li>
</ul>
</li>
</ul>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><ul>
<li>var <ul>
<li>自动添加到最接近的上下文</li>
<li>拿到函数或全局作用域的顶部（作用域链的尾部） ===》 变量提升</li>
</ul>
</li>
<li>let<ul>
<li>块级作用域</li>
<li>同一作用域不能声明两次 声明后的变量，值可以改变</li>
<li>由于“暂时性死区” ， （变量声明之前无法引用） ， let 也会被提升，不过跟var的变量提升有本质的不同</li>
</ul>
</li>
<li>const<ul>
<li>块级作用域</li>
<li>不能重新赋值</li>
</ul>
</li>
</ul>
<h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>自动内存管理实现内存分配和闲置资源回收</li>
<li>基本思路：周期性的确定哪个变量不会再使用，然后释放它的内存。</li>
<li>常用办法：<strong>标记清理</strong> 、 引用计数 </li>
</ul>
<h4 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h4><ul>
<li>标记内存中的所有变量</li>
<li>去掉所有在上下文中的变量以及上下文引用的变量的标记</li>
<li>剩下的就是不使用的变量 回收</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>减少垃圾回收的次数</li>
<li>动态改变垃圾回收的阈值</li>
</ul>
<h2 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h2><ul>
<li>优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据</li>
<li>数据不再使用，可以把他设置为 <code>null</code> ,释放引用。垃圾回收时会被回收</li>
</ul>
<h4 id="通过const-let-声明提升性能"><a href="#通过const-let-声明提升性能" class="headerlink" title="通过const let 声明提升性能"></a>通过const let 声明提升性能</h4><ul>
<li>块作用域，可以更早的垃圾回收</li>
</ul>
<h4 id="隐藏类和删除操作"><a href="#隐藏类和删除操作" class="headerlink" title="隐藏类和删除操作"></a>隐藏类和删除操作</h4><h4 id="内存泄漏（闭包）"><a href="#内存泄漏（闭包）" class="headerlink" title="内存泄漏（闭包）"></a>内存泄漏（闭包）</h4><h4 id="静态分配与对象池"><a href="#静态分配与对象池" class="headerlink" title="静态分配与对象池"></a>静态分配与对象池</h4>]]></content>
      <categories>
        <category>基础笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
